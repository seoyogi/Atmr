<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸŒ¿ ã‚ã¤ã¾ã‚Œï¼ã©ã†ã¶ã¤ã®æ£® é¢¨ã‚²ãƒ¼ãƒ </title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  
  body {
    font-family: 'Zen Maru Gothic', 'M PLUS Rounded 1c', sans-serif;
    background: #87CEEB;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
    user-select: none;
  }

  #root {
    width: 100vw;
    height: 100vh;
    position: relative;
  }

  /* HUD */
  #hud {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    z-index: 10;
  }

  /* ãƒˆãƒƒãƒ—ãƒãƒ¼ */
  #topbar {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 12px;
    background: rgba(255,255,255,0.88);
    border: 3px solid #a8d5a2;
    border-radius: 999px;
    padding: 6px 20px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15), inset 0 1px 0 rgba(255,255,255,0.8);
    pointer-events: all;
  }

  #island-name {
    font-size: 18px;
    font-weight: 900;
    color: #3a7d44;
    text-shadow: 1px 1px 0 rgba(255,255,255,0.8);
  }

  #bell-display {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 15px;
    font-weight: 700;
    color: #c47f00;
  }

  /* æ™‚è¨ˆ */
  #clock {
    position: absolute;
    top: 12px;
    right: 16px;
    background: rgba(255,255,255,0.88);
    border: 3px solid #a8d5a2;
    border-radius: 16px;
    padding: 6px 14px;
    font-size: 14px;
    font-weight: 700;
    color: #3a7d44;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
  }

  /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
  #toolbar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 10px;
    align-items: center;
    pointer-events: all;
  }

  .tool-btn {
    width: 64px;
    height: 64px;
    background: rgba(255,255,255,0.92);
    border: 3px solid #a8d5a2;
    border-radius: 18px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.15s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15), 0 2px 0 #6bb56a;
    font-size: 26px;
    gap: 2px;
  }

  .tool-btn:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(0,0,0,0.2), 0 2px 0 #6bb56a;
    background: #f0fef0;
  }

  .tool-btn:active {
    transform: translateY(0px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.15), 0 1px 0 #6bb56a;
  }

  .tool-btn.active {
    background: #d4f0d4;
    border-color: #3a7d44;
    transform: translateY(-2px);
  }

  .tool-label {
    font-size: 9px;
    font-weight: 700;
    color: #3a7d44;
    line-height: 1;
  }

  /* æ“ä½œã‚¬ã‚¤ãƒ‰ */
  #controls-guide {
    position: absolute;
    bottom: 100px;
    left: 16px;
    background: rgba(255,255,255,0.82);
    border: 2px solid #a8d5a2;
    border-radius: 12px;
    padding: 10px 14px;
    font-size: 11px;
    color: #3a7d44;
    font-weight: 600;
    line-height: 1.8;
    pointer-events: all;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  }

  /* ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª */
  #inventory {
    position: absolute;
    top: 70px;
    right: 16px;
    background: rgba(255,255,255,0.88);
    border: 3px solid #a8d5a2;
    border-radius: 16px;
    padding: 12px;
    pointer-events: all;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    min-width: 120px;
  }

  #inventory h3 {
    font-size: 12px;
    font-weight: 700;
    color: #3a7d44;
    margin-bottom: 8px;
    text-align: center;
    border-bottom: 2px solid #a8d5a2;
    padding-bottom: 5px;
  }

  .inv-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    color: #555;
    font-weight: 600;
    padding: 2px 0;
  }

  /* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  #action-msg {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255,255,255,0.95);
    border: 3px solid #a8d5a2;
    border-radius: 20px;
    padding: 16px 28px;
    font-size: 16px;
    font-weight: 700;
    color: #3a7d44;
    text-align: center;
    box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    display: none;
    z-index: 100;
    pointer-events: none;
    animation: msgPop 0.3s ease-out;
  }

  @keyframes msgPop {
    from { transform: translate(-50%, -50%) scale(0.8); opacity: 0; }
    to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
  }

  /* å¤©æ°—ãƒ‘ãƒãƒ« */
  #weather-panel {
    position: absolute;
    top: 70px;
    left: 16px;
    background: rgba(255,255,255,0.88);
    border: 3px solid #a8d5a2;
    border-radius: 16px;
    padding: 10px 14px;
    pointer-events: all;
    box-shadow: 0 4px 16px rgba(0,0,0,0.15);
    font-size: 13px;
    color: #3a7d44;
    font-weight: 700;
  }

  /* ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ */
  #title-screen {
    position: fixed;
    inset: 0;
    background: linear-gradient(180deg, #7dd4f0 0%, #a8e6cf 50%, #68b36b 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    animation: fadeTitle 0.5s ease;
  }

  @keyframes fadeTitle {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  #title-screen.hidden {
    animation: fadeOut 0.8s ease forwards;
  }

  @keyframes fadeOut {
    to { opacity: 0; pointer-events: none; }
  }

  .title-logo {
    text-align: center;
    margin-bottom: 40px;
  }

  .title-logo h1 {
    font-size: clamp(28px, 5vw, 48px);
    font-weight: 900;
    color: #fff;
    text-shadow: 3px 3px 0 #3a7d44, -1px -1px 0 #3a7d44, 1px -1px 0 #3a7d44;
    letter-spacing: 2px;
    line-height: 1.3;
  }

  .title-logo p {
    font-size: 16px;
    color: #fff;
    margin-top: 8px;
    font-weight: 600;
    text-shadow: 1px 1px 0 rgba(0,0,0,0.3);
  }

  .start-btn {
    background: #fff;
    border: 4px solid #3a7d44;
    border-radius: 999px;
    padding: 14px 48px;
    font-size: 20px;
    font-weight: 900;
    color: #3a7d44;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 6px 0 #3a7d44, 0 8px 20px rgba(0,0,0,0.2);
    font-family: inherit;
    animation: bounce 1.5s ease-in-out infinite;
  }

  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-6px); }
  }

  .start-btn:hover {
    background: #f0fef0;
    box-shadow: 0 4px 0 #3a7d44, 0 6px 16px rgba(0,0,0,0.2);
    transform: translateY(2px);
    animation: none;
  }

  .grass-deco {
    display: flex;
    gap: 8px;
    font-size: 40px;
    margin: 20px 0;
    animation: float 3s ease-in-out infinite;
  }

  @keyframes float {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-8px); }
  }

  canvas { display: block; }

  #loading {
    position: fixed;
    inset: 0;
    background: #87CEEB;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 999;
    font-size: 18px;
    font-weight: 700;
    color: #3a7d44;
  }

  .spinner {
    width: 50px;
    height: 50px;
    border: 5px solid #a8d5a2;
    border-top-color: #3a7d44;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    margin-bottom: 16px;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700;900&display=swap" rel="stylesheet">
</head>
<body>

<!-- ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ -->
<div id="title-screen">
  <div class="title-logo">
    <h1>ğŸŒ¿ ã‚ã¤ã¾ã‚Œï¼<br>ã©ã†ã¶ã¤ã®æ£®</h1>
    <p>ï½ ã¿ã‚“ãªã®ã—ã¾ã¸ ã‚ˆã†ã“ã ï½</p>
  </div>
  <div class="grass-deco">ğŸŒ¸ ğŸŒ³ ğŸ¦‹ ğŸŒ» ğŸ</div>
  <button class="start-btn" onclick="startGame()">ğŸ® ã¯ã˜ã‚ã‚‹ï¼</button>
</div>

<!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° -->
<div id="loading" style="display:none">
  <div class="spinner"></div>
  ã—ã¾ã‚’æº–å‚™ä¸­...
</div>

<!-- 3Dã‚­ãƒ£ãƒ³ãƒã‚¹ -->
<div id="root"></div>

<!-- HUD -->
<div id="hud" style="display:none">
  <div id="topbar">
    <span id="island-name">ğŸŒ´ ãµã‚ãµã‚ã—ã¾</span>
    <div id="bell-display">ğŸ”” <span id="bell-count">12,500</span> ãƒ™ãƒ«</div>
  </div>

  <div id="clock">ğŸ• <span id="time-display">--:--</span></div>

  <div id="weather-panel">
    â˜€ï¸ ã¯ã‚Œ<br>
    <span style="font-size:10px; font-weight:500; color:#666">æ°—æ¸©: 22Â°C</span>
  </div>

  <div id="inventory">
    <h3>ğŸ’ ã‚‚ã¡ã‚‚ã®</h3>
    <div class="inv-item">ğŸª“ <span id="axe-count">0</span> æœ¨æ</div>
    <div class="inv-item">ğŸŸ <span id="fish-count">0</span> ã•ã‹ãª</div>
    <div class="inv-item">ğŸŒ¸ <span id="flower-count">0</span> ã¯ãª</div>
    <div class="inv-item">ğŸ„ <span id="mushroom-count">0</span> ãã®ã“</div>
  </div>

  <div id="controls-guide">
    <b>ğŸ® æ“ä½œæ–¹æ³•</b><br>
    WASD / çŸ¢å° â†’ ç§»å‹•<br>
    ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚° â†’ è¦–ç‚¹å›è»¢<br>
    ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ« â†’ ã‚ºãƒ¼ãƒ <br>
    ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ â†’ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³<br>
    <b>E / ã‚¯ãƒªãƒƒã‚¯</b> â†’ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒˆ
  </div>

  <div id="toolbar">
    <div class="tool-btn active" id="btn-walk" onclick="setTool('walk')">
      ğŸƒ <span class="tool-label">æ­©ã</span>
    </div>
    <div class="tool-btn" id="btn-axe" onclick="setTool('axe')">
      ğŸª“ <span class="tool-label">ãŠã®</span>
    </div>
    <div class="tool-btn" id="btn-fish" onclick="setTool('fish')">
      ğŸ£ <span class="tool-label">ã¤ã‚Š</span>
    </div>
    <div class="tool-btn" id="btn-flower" onclick="setTool('flower')">
      ğŸŒ¸ <span class="tool-label">ã¯ãªã¤ã¿</span>
    </div>
    <div class="tool-btn" id="btn-chat" onclick="setTool('chat')">
      ğŸ’¬ <span class="tool-label">ã¯ãªã™</span>
    </div>
  </div>

  <div id="action-msg"></div>
</div>

<!-- Three.js + React Three Fiber (UMD builds via CDN) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ===== ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆPure Three.js - é«˜ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ï¼‰ =====
const clock = new THREE.Clock();
let scene, camera, renderer, mixer;
let player = null;
let playerBody = null;
let moveDir = { x: 0, z: 0 };
let currentTool = 'walk';
let gameStarted = false;
let bells = 12500;
let inventory = { wood: 0, fish: 0, flower: 0, mushroom: 0 };
let interactables = [];
let npcs = [];
let particles = [];
let cameraAngle = 0;
let cameraDistance = 12;
let cameraPitch = 0.6;
let isDragging = false;
let lastMouse = { x: 0, y: 0 };

// GLBãƒ¢ãƒ‡ãƒ«ãƒ­ãƒ¼ãƒ€ãƒ¼
let GLTFLoader;

function loadGLTFLoaderScript() {
  return new Promise((resolve) => {
    const script = document.createElement('script');
    // inline GLTFLoader (minimal version for loading)
    resolve();
  });
}

// ========== ã‚²ãƒ¼ãƒ é–‹å§‹ ==========
function startGame() {
  document.getElementById('title-screen').classList.add('hidden');
  document.getElementById('loading').style.display = 'flex';
  
  setTimeout(() => {
    initGame();
    document.getElementById('loading').style.display = 'none';
    document.getElementById('hud').style.display = 'block';
    gameStarted = true;
    updateClock();
    setInterval(updateClock, 60000);
    animate();
  }, 1200);
}

// ========== ã‚·ãƒ¼ãƒ³åˆæœŸåŒ– ==========
function initGame() {
  // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.setClearColor(0x87CEEB);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.getElementById('root').appendChild(renderer.domElement);

  // ã‚·ãƒ¼ãƒ³
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87CEEB);
  scene.fog = new THREE.FogExp2(0x87CEEB, 0.018);

  // ã‚«ãƒ¡ãƒ©
  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
  updateCamera();

  // å…‰æº
  const ambientLight = new THREE.AmbientLight(0xfff5e0, 0.7);
  scene.add(ambientLight);
  
  const sunLight = new THREE.DirectionalLight(0xfff8d0, 1.2);
  sunLight.position.set(20, 40, 20);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.set(2048, 2048);
  sunLight.shadow.camera.near = 0.1;
  sunLight.shadow.camera.far = 100;
  sunLight.shadow.camera.left = -40;
  sunLight.shadow.camera.right = 40;
  sunLight.shadow.camera.top = 40;
  sunLight.shadow.camera.bottom = -40;
  scene.add(sunLight);

  const fillLight = new THREE.HemisphereLight(0x87CEEB, 0x68b36b, 0.5);
  scene.add(fillLight);

  // å³¶ã®åœ°é¢
  createIsland();
  
  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…ç½®
  createTrees();
  createFlowers();
  createRiver();
  createHouses();
  createMushrooms();
  createNPCs();
  
  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ï¼ˆGLBãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ï¼‰
  loadPlayerModel();

  // ã‚¤ãƒ™ãƒ³ãƒˆ
  window.addEventListener('resize', onResize);
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  renderer.domElement.addEventListener('mousedown', onMouseDown);
  renderer.domElement.addEventListener('mousemove', onMouseMove);
  renderer.domElement.addEventListener('mouseup', onMouseUp);
  renderer.domElement.addEventListener('wheel', onWheel);
  renderer.domElement.addEventListener('click', onCanvasClick);
}

// ========== å³¶ã®ä½œæˆ ==========
function createIsland() {
  // ãƒ¡ã‚¤ãƒ³åœ°é¢
  const groundGeo = new THREE.CircleGeometry(40, 64);
  const groundMat = new THREE.MeshLambertMaterial({ color: 0x68b36b });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI / 2;
  ground.receiveShadow = true;
  scene.add(ground);

  // æ°´é¢ï¼ˆæµ·ï¼‰
  const seaGeo = new THREE.CircleGeometry(60, 64);
  const seaMat = new THREE.MeshLambertMaterial({ color: 0x4ab5cc, transparent: true, opacity: 0.9 });
  const sea = new THREE.Mesh(seaGeo, seaMat);
  sea.rotation.x = -Math.PI / 2;
  sea.position.y = -0.2;
  scene.add(sea);

  // ç ‚æµœ
  const beachGeo = new THREE.RingGeometry(36, 42, 64);
  const beachMat = new THREE.MeshLambertMaterial({ color: 0xf5e0a0 });
  const beach = new THREE.Mesh(beachGeo, beachMat);
  beach.rotation.x = -Math.PI / 2;
  beach.position.y = 0.01;
  scene.add(beach);

  // ãƒ‘ã‚¹ï¼ˆå°é“ï¼‰
  for (let i = 0; i < 8; i++) {
    const pathGeo = new THREE.BoxGeometry(1.5, 0.02, 2.5);
    const pathMat = new THREE.MeshLambertMaterial({ color: 0xe8d5a0 });
    const path = new THREE.Mesh(pathGeo, pathMat);
    path.position.set(Math.sin(i * Math.PI / 4) * 5, 0.01, Math.cos(i * Math.PI / 4) * 5);
    path.rotation.y = i * Math.PI / 4;
    scene.add(path);
  }

  // æ°´é¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
  scene.userData.sea = sea;
}

// ========== æœ¨ã®ä½œæˆ ==========
function createTrees() {
  const treePositions = [
    [-8, 0, -8], [8, 0, -10], [-12, 0, 3], [12, 0, 5],
    [-6, 0, 12], [7, 0, 13], [-14, 0, -2], [14, 0, -3],
    [-3, 0, -15], [4, 0, -16], [0, 0, -12], [-10, 0, 10],
    [10, 0, -8], [-5, 0, 18], [5, 0, 19], [-18, 0, 6],
    [18, 0, 2], [-16, 0, -10], [16, 0, -9]
  ];

  treePositions.forEach((pos, i) => {
    createTree(pos[0], pos[2], i);
  });
}

function createTree(x, z, seed) {
  const group = new THREE.Group();
  
  // æœ¨ã®ç¨®é¡ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«
  const types = ['normal', 'fruit', 'palm'];
  const type = types[seed % 3];
  
  if (type === 'palm') {
    // ãƒ¤ã‚·ã®æœ¨
    const trunkGeo = new THREE.CylinderGeometry(0.12, 0.2, 4, 8);
    const trunkMat = new THREE.MeshLambertMaterial({ color: 0xa0724a });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 2;
    trunk.castShadow = true;
    group.add(trunk);

    for (let i = 0; i < 6; i++) {
      const leafGeo = new THREE.ConeGeometry(0.3, 2, 4);
      const leafMat = new THREE.MeshLambertMaterial({ color: 0x4a9e4a });
      const leaf = new THREE.Mesh(leafGeo, leafMat);
      leaf.position.set(
        Math.cos(i * Math.PI / 3) * 1.2, 3.8,
        Math.sin(i * Math.PI / 3) * 1.2
      );
      leaf.rotation.z = Math.PI * 0.3;
      leaf.rotation.y = i * Math.PI / 3;
      group.add(leaf);
    }
  } else {
    // é€šå¸¸ã®æœ¨
    const trunkGeo = new THREE.CylinderGeometry(0.18, 0.25, 2.5, 8);
    const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B5A2B });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1.25;
    trunk.castShadow = true;
    group.add(trunk);

    // è‘‰ï¼ˆ3æ®µï¼‰
    const leafColors = [0x2d8a2d, 0x3aa33a, 0x4ab54a];
    [3.5, 2.8, 2.2].forEach((h, j) => {
      const leafGeo = new THREE.SphereGeometry(2.5 - j * 0.5, 8, 6);
      const leafMat = new THREE.MeshLambertMaterial({ color: leafColors[j] });
      const leaf = new THREE.Mesh(leafGeo, leafMat);
      leaf.position.y = h;
      leaf.scale.y = 0.7;
      leaf.castShadow = true;
      group.add(leaf);
    });

    // ãƒ•ãƒ«ãƒ¼ãƒ„
    if (type === 'fruit') {
      const fruitColors = [0xff4444, 0xff8800, 0xffcc00];
      const fruitColor = fruitColors[seed % 3];
      for (let i = 0; i < 4; i++) {
        const fruitGeo = new THREE.SphereGeometry(0.2, 6, 6);
        const fruitMat = new THREE.MeshLambertMaterial({ color: fruitColor });
        const fruit = new THREE.Mesh(fruitGeo, fruitMat);
        fruit.position.set(
          Math.cos(i * Math.PI / 2) * 1.5, 2.5,
          Math.sin(i * Math.PI / 2) * 1.5
        );
        group.add(fruit);
      }
    }
  }

  group.position.set(x, 0, z);
  group.userData = { type: 'tree', hasWood: true };
  scene.add(group);
  interactables.push(group);
}

// ========== èŠ±ã®ä½œæˆ ==========
function createFlowers() {
  const flowerPositions = [
    [-4, 0, -4], [4, 0, -5], [-6, 0, 6], [6, 0, 8],
    [2, 0, 10], [-3, 0, 7], [0, 0, -8], [-8, 0, -1],
    [8, 0, 1], [3, 0, -12], [-2, 0, -10]
  ];

  const flowerColors = [0xff69b4, 0xff4444, 0xffcc00, 0xff88cc, 0xaa44ff, 0xffffff];
  
  flowerPositions.forEach((pos, i) => {
    const group = new THREE.Group();
    
    // èŒ
    const stemGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.5, 6);
    const stemMat = new THREE.MeshLambertMaterial({ color: 0x4a9e4a });
    const stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.y = 0.25;
    group.add(stem);

    // èŠ±ã³ã‚‰
    const petalColor = flowerColors[i % flowerColors.length];
    for (let j = 0; j < 5; j++) {
      const petalGeo = new THREE.SphereGeometry(0.15, 6, 4);
      const petalMat = new THREE.MeshLambertMaterial({ color: petalColor });
      const petal = new THREE.Mesh(petalGeo, petalMat);
      petal.position.set(
        Math.cos(j * Math.PI * 2 / 5) * 0.2, 0.5,
        Math.sin(j * Math.PI * 2 / 5) * 0.2
      );
      petal.scale.set(1, 0.5, 1);
      group.add(petal);
    }
    
    // èŠ±èŠ¯
    const coreGeo = new THREE.SphereGeometry(0.12, 8, 8);
    const coreMat = new THREE.MeshLambertMaterial({ color: 0xffdd00 });
    const core = new THREE.Mesh(coreGeo, coreMat);
    core.position.y = 0.52;
    group.add(core);

    group.position.set(pos[0], 0, pos[2]);
    group.userData = { type: 'flower', hasFlower: true };
    scene.add(group);
    interactables.push(group);
  });
}

// ========== å·ã®ä½œæˆ ==========
function createRiver() {
  const points = [];
  for (let i = 0; i <= 20; i++) {
    const t = i / 20;
    points.push(new THREE.Vector3(
      Math.sin(t * Math.PI * 2) * 3 - 6,
      0.05,
      t * 30 - 18
    ));
  }
  
  const curve = new THREE.CatmullRomCurve3(points);
  const tubeGeo = new THREE.TubeGeometry(curve, 30, 0.8, 8, false);
  const tubeMat = new THREE.MeshLambertMaterial({ 
    color: 0x4ab5cc, transparent: true, opacity: 0.85 
  });
  const river = new THREE.Mesh(tubeGeo, tubeMat);
  scene.add(river);
  
  // é‡£ã‚Šãƒã‚¤ãƒ³ãƒˆ
  const fishPoint = new THREE.Group();
  const fpGeo = new THREE.SphereGeometry(0.3, 8, 8);
  const fpMat = new THREE.MeshLambertMaterial({ color: 0x4ab5cc, transparent: true, opacity: 0.6 });
  const fp = new THREE.Mesh(fpGeo, fpMat);
  fp.position.y = 0.2;
  fishPoint.add(fp);
  fishPoint.position.set(-6, 0, 0);
  fishPoint.userData = { type: 'river', hasFish: true };
  scene.add(fishPoint);
  interactables.push(fishPoint);
}

// ========== å®¶ã®ä½œæˆ ==========
function createHouses() {
  createHouse(0, -20, 0, 0xffdab9, 'ğŸ '); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å®¶
  createHouse(-8, -22, 0, 0xffc0cb, 'ğŸ¡'); // NPCå®¶1
  createHouse(8, -22, 0, 0xc0e8ff, 'ğŸ¡'); // NPCå®¶2
}

function createHouse(x, z, ry, wallColor, emoji) {
  const group = new THREE.Group();

  // å£
  const wallGeo = new THREE.BoxGeometry(4, 3, 4);
  const wallMat = new THREE.MeshLambertMaterial({ color: wallColor });
  const wall = new THREE.Mesh(wallGeo, wallMat);
  wall.position.y = 1.5;
  wall.castShadow = true;
  wall.receiveShadow = true;
  group.add(wall);

  // å±‹æ ¹
  const roofGeo = new THREE.ConeGeometry(3.2, 2, 4);
  const roofMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
  const roof = new THREE.Mesh(roofGeo, roofMat);
  roof.position.y = 4;
  roof.rotation.y = Math.PI / 4;
  roof.castShadow = true;
  group.add(roof);

  // ãƒ‰ã‚¢
  const doorGeo = new THREE.BoxGeometry(0.8, 1.5, 0.1);
  const doorMat = new THREE.MeshLambertMaterial({ color: 0x8B5A2B });
  const door = new THREE.Mesh(doorGeo, doorMat);
  door.position.set(0, 0.75, 2.05);
  group.add(door);

  // çª“
  [-1.2, 1.2].forEach(wx => {
    const winGeo = new THREE.BoxGeometry(0.7, 0.7, 0.1);
    const winMat = new THREE.MeshLambertMaterial({ color: 0x87ceeb });
    const win = new THREE.Mesh(winGeo, winMat);
    win.position.set(wx, 1.8, 2.05);
    group.add(win);
  });

  group.position.set(x, 0, z);
  group.rotation.y = ry;
  scene.add(group);
}

// ========== ãã®ã“ã®ä½œæˆ ==========
function createMushrooms() {
  const positions = [[3, 0, 2], [-5, 0, 4], [7, 0, -3], [-2, 0, 9]];
  
  positions.forEach((pos, i) => {
    const group = new THREE.Group();
    
    const stemGeo = new THREE.CylinderGeometry(0.12, 0.16, 0.5, 8);
    const stemMat = new THREE.MeshLambertMaterial({ color: 0xfffacd });
    const stem = new THREE.Mesh(stemGeo, stemMat);
    stem.position.y = 0.25;
    group.add(stem);

    const capGeo = new THREE.SphereGeometry(0.35, 8, 6, 0, Math.PI * 2, 0, Math.PI * 0.6);
    const capColors = [0xff4444, 0xff8800, 0xffcc00, 0xaa44ff];
    const capMat = new THREE.MeshLambertMaterial({ color: capColors[i] });
    const cap = new THREE.Mesh(capGeo, capMat);
    cap.position.y = 0.6;
    group.add(cap);

    // æ°´ç‰
    for (let j = 0; j < 4; j++) {
      const dotGeo = new THREE.SphereGeometry(0.05, 4, 4);
      const dotMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
      const dot = new THREE.Mesh(dotGeo, dotMat);
      dot.position.set(
        Math.cos(j * Math.PI / 2) * 0.22, 0.72,
        Math.sin(j * Math.PI / 2) * 0.22
      );
      group.add(dot);
    }

    group.position.set(pos[0], 0, pos[2]);
    group.userData = { type: 'mushroom', hasMushroom: true };
    scene.add(group);
    interactables.push(group);
  });
}

// ========== NPCã®ä½œæˆ ==========
function createNPCs() {
  const npcData = [
    { x: -6, z: 2, color: 0xffaa88, name: 'ãŸã¬ã' },
    { x: 5, z: -5, color: 0x88aaff, name: 'ã‚Šã™ã®ã“' },
    { x: -3, z: 8, color: 0xff88aa, name: 'ã†ã—ã“' },
  ];

  npcData.forEach(data => {
    const group = new THREE.Group();

    // ä½“
    const bodyGeo = new THREE.CapsuleGeometry(0.35, 0.6, 4, 8);
    const bodyMat = new THREE.MeshLambertMaterial({ color: data.color });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.85;
    body.castShadow = true;
    group.add(body);

    // é ­
    const headGeo = new THREE.SphereGeometry(0.38, 8, 8);
    const headMat = new THREE.MeshLambertMaterial({ color: data.color });
    const head = new THREE.Mesh(headGeo, headMat);
    head.position.y = 1.7;
    head.castShadow = true;
    group.add(head);

    // ç›®
    [-0.12, 0.12].forEach(ex => {
      const eyeGeo = new THREE.SphereGeometry(0.06, 6, 6);
      const eyeMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
      const eye = new THREE.Mesh(eyeGeo, eyeMat);
      eye.position.set(ex, 1.76, 0.3);
      group.add(eye);
    });

    // è€³
    [-0.22, 0.22].forEach(ex => {
      const earGeo = new THREE.SphereGeometry(0.12, 6, 6);
      const earMat = new THREE.MeshLambertMaterial({ color: data.color });
      const ear = new THREE.Mesh(earGeo, earMat);
      ear.position.set(ex, 2.05, 0);
      ear.scale.y = 1.4;
      group.add(ear);
    });

    group.position.set(data.x, 0, data.z);
    group.userData = { type: 'npc', name: data.name };
    group.userData.walkAngle = Math.random() * Math.PI * 2;
    group.userData.walkRadius = 2 + Math.random() * 1.5;
    group.userData.walkSpeed = 0.3 + Math.random() * 0.3;
    group.userData.baseX = data.x;
    group.userData.baseZ = data.z;
    
    scene.add(group);
    npcs.push(group);
    interactables.push(group);
  });
}

// ========== ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿ ==========
function loadPlayerModel() {
  // GLTFLoaderã‚’CDNã‹ã‚‰å‹•çš„ã«èª­ã¿è¾¼ã‚€
  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/loaders/GLTFLoader.js';
  script.onload = () => {
    try {
      const loader = new THREE.GLTFLoader();
      // ãƒ•ã‚¡ã‚¤ãƒ«ã¯outputsãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã«é…ç½®æ¸ˆã¿
      loader.load(
        'girl_character_3d_model.glb',
        (gltf) => {
          player = gltf.scene;
          // ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ï¼ˆGLBã®ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ï¼‰
          player.scale.set(1, 1, 1);
          
          // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã§ã‚µã‚¤ã‚ºã‚’ç¢ºèªã—ã¦ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´
          const bbox = new THREE.Box3().setFromObject(player);
          const size = new THREE.Vector3();
          bbox.getSize(size);
          const maxDim = Math.max(size.x, size.y, size.z);
          if (maxDim > 0) {
            const targetHeight = 1.8;
            const scale = targetHeight / maxDim;
            player.scale.set(scale, scale, scale);
          }
          
          player.position.set(0, 0, 0);
          player.traverse(child => {
            if (child.isMesh) {
              child.castShadow = true;
              child.receiveShadow = true;
            }
          });

          // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
          if (gltf.animations && gltf.animations.length > 0) {
            mixer = new THREE.AnimationMixer(player);
            const idleAnim = gltf.animations[0];
            const action = mixer.clipAction(idleAnim);
            action.play();
          }

          scene.add(player);
          playerBody = player;
        },
        undefined,
        (err) => {
          console.warn('GLB load error:', err);
          createFallbackPlayer();
        }
      );
    } catch(e) {
      createFallbackPlayer();
    }
  };
  script.onerror = () => createFallbackPlayer();
  document.head.appendChild(script);
}

function createFallbackPlayer() {
  // GLBãŒèª­ã¿è¾¼ã‚ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆã‹ã‚ã„ã„ã‚­ãƒ£ãƒ©ï¼‰
  const group = new THREE.Group();
  
  // ä½“
  const bodyGeo = new THREE.CapsuleGeometry(0.3, 0.6, 4, 8);
  const bodyMat = new THREE.MeshLambertMaterial({ color: 0xff8fa0 });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.9;
  body.castShadow = true;
  group.add(body);

  // é ­
  const headGeo = new THREE.SphereGeometry(0.36, 10, 10);
  const headMat = new THREE.MeshLambertMaterial({ color: 0xffcdb4 });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.7;
  head.castShadow = true;
  group.add(head);

  // ç›®
  [-0.13, 0.13].forEach(ex => {
    const eyeGeo = new THREE.SphereGeometry(0.065, 6, 6);
    const eyeMat = new THREE.MeshLambertMaterial({ color: 0x3a2020 });
    const eye = new THREE.Mesh(eyeGeo, eyeMat);
    eye.position.set(ex, 1.75, 0.3);
    group.add(eye);
    
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
    const hlGeo = new THREE.SphereGeometry(0.02, 4, 4);
    const hlMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
    const hl = new THREE.Mesh(hlGeo, hlMat);
    hl.position.set(ex + 0.02, 1.77, 0.35);
    group.add(hl);
  });

  // é ¬
  [-0.24, 0.24].forEach(cx => {
    const cheekGeo = new THREE.SphereGeometry(0.1, 6, 6);
    const cheekMat = new THREE.MeshLambertMaterial({ color: 0xffaaaa, transparent: true, opacity: 0.7 });
    const cheek = new THREE.Mesh(cheekGeo, cheekMat);
    cheek.position.set(cx, 1.65, 0.28);
    cheek.scale.z = 0.3;
    group.add(cheek);
  });

  // é«ª
  const hairGeo = new THREE.SphereGeometry(0.4, 8, 8);
  const hairMat = new THREE.MeshLambertMaterial({ color: 0x3a2010 });
  const hair = new THREE.Mesh(hairGeo, hairMat);
  hair.position.y = 1.95;
  hair.scale.set(1, 0.65, 1);
  group.add(hair);

  group.position.set(0, 0, 0);
  scene.add(group);
  player = group;
  playerBody = group;
}

// ========== ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ« ==========
function spawnParticles(x, y, z, color) {
  for (let i = 0; i < 12; i++) {
    const geo = new THREE.SphereGeometry(0.06, 4, 4);
    const mat = new THREE.MeshBasicMaterial({ color });
    const p = new THREE.Mesh(geo, mat);
    p.position.set(x, y, z);
    p.userData.vel = new THREE.Vector3(
      (Math.random() - 0.5) * 0.2,
      0.1 + Math.random() * 0.15,
      (Math.random() - 0.5) * 0.2
    );
    p.userData.life = 1.0;
    scene.add(p);
    particles.push(p);
  }
}

// ========== ã‚«ãƒ¡ãƒ©æ›´æ–° ==========
function updateCamera() {
  if (!camera) return;
  const px = player ? player.position.x : 0;
  const pz = player ? player.position.z : 0;
  const py = player ? player.position.y : 0;
  
  camera.position.set(
    px + Math.sin(cameraAngle) * cameraDistance * Math.cos(cameraPitch),
    py + cameraDistance * Math.sin(cameraPitch),
    pz + Math.cos(cameraAngle) * cameraDistance * Math.cos(cameraPitch)
  );
  camera.lookAt(px, py + 1, pz);
}

// ========== å…¥åŠ›å‡¦ç† ==========
const keys = {};

function onKeyDown(e) {
  keys[e.key.toLowerCase()] = true;
  if (e.key.toLowerCase() === 'e') tryInteract();
}

function onKeyUp(e) {
  keys[e.key.toLowerCase()] = false;
}

function onMouseDown(e) {
  if (e.button === 0 && e.target === renderer.domElement) {
    isDragging = true;
    lastMouse = { x: e.clientX, y: e.clientY };
  }
}

function onMouseMove(e) {
  if (!isDragging) return;
  const dx = e.clientX - lastMouse.x;
  const dy = e.clientY - lastMouse.y;
  cameraAngle += dx * 0.008;
  cameraPitch = Math.max(0.1, Math.min(1.2, cameraPitch - dy * 0.005));
  lastMouse = { x: e.clientX, y: e.clientY };
}

function onMouseUp() {
  isDragging = false;
}

function onWheel(e) {
  cameraDistance = Math.max(4, Math.min(25, cameraDistance + e.deltaY * 0.01));
}

function onCanvasClick(e) {
  if (Math.abs(e.movementX) + Math.abs(e.movementY) > 5) return;
  tryInteract();
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

// ========== ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ ==========
function tryInteract() {
  if (!player) return;
  let nearest = null;
  let nearestDist = 3.5;
  
  interactables.forEach(obj => {
    const dist = player.position.distanceTo(obj.position);
    if (dist < nearestDist) {
      nearest = obj;
      nearestDist = dist;
    }
  });

  if (nearest) {
    const type = nearest.userData.type;
    
    if (type === 'tree' && nearest.userData.hasWood) {
      if (currentTool === 'axe') {
        inventory.wood++;
        bells += 150;
        nearest.userData.hasWood = false;
        showMessage('ğŸª“ æœ¨æã‚’ã‚²ãƒƒãƒˆï¼\n+150ãƒ™ãƒ« ğŸ’°');
        spawnParticles(nearest.position.x, 2, nearest.position.z, 0xc8a060);
        updateInventory();
        // æœ¨ã‚’æºã‚‰ã™
        const origY = nearest.position.y;
        const shake = () => {
          nearest.position.x += (Math.random() - 0.5) * 0.1;
          nearest.position.y += 0.05;
        };
        setTimeout(() => nearest.position.x = nearest.position.x, 300);
      } else {
        showMessage('ğŸª“ ãŠã®ã‚’é¸ã‚“ã§\næœ¨ã‚’åˆ‡ã‚ã†ï¼');
      }
    } else if (type === 'river' && nearest.userData.hasFish) {
      if (currentTool === 'fish') {
        inventory.fish++;
        bells += 300;
        showMessage('ğŸŸ ã•ã‹ãªã‚’é‡£ã£ãŸï¼\n+300ãƒ™ãƒ« ğŸ’°');
        spawnParticles(nearest.position.x, 0.5, nearest.position.z, 0x4ab5cc);
        updateInventory();
      } else {
        showMessage('ğŸ£ ã¤ã‚Šã–ãŠã‚’é¸ã‚“ã§\nå·ã§é‡£ã‚Šã‚’ã—ã‚ˆã†ï¼');
      }
    } else if (type === 'flower' && nearest.userData.hasFlower) {
      if (currentTool === 'flower' || currentTool === 'walk') {
        inventory.flower++;
        bells += 80;
        nearest.userData.hasFlower = false;
        nearest.visible = false;
        showMessage('ğŸŒ¸ ã¯ãªã‚’æ‘˜ã‚“ã ï¼\n+80ãƒ™ãƒ« ğŸ’°');
        spawnParticles(nearest.position.x, 0.5, nearest.position.z, 0xff69b4);
        updateInventory();
      }
    } else if (type === 'mushroom' && nearest.userData.hasMushroom) {
      inventory.mushroom++;
      bells += 200;
      nearest.userData.hasMushroom = false;
      nearest.visible = false;
      showMessage('ğŸ„ ãã®ã“ã‚’ã¨ã£ãŸï¼\n+200ãƒ™ãƒ« ğŸ’°');
      spawnParticles(nearest.position.x, 0.5, nearest.position.z, 0xff4444);
      updateInventory();
    } else if (type === 'npc') {
      const messages = [
        `ã€Œã“ã‚“ã«ã¡ã¯ï¼\n${nearest.userData.name}ã ã‚ˆï¼âœ¨ã€`,
        `ã€Œä»Šæ—¥ã‚‚ã„ã„å¤©æ°—ã ã­ï¼\nã„ã£ã—ã‚‡ã«ã‚ãã¼ã†â™ªã€`,
        `ã€Œãã‚Œã„ãªèŠ±ã ã­ã€œ\nãŸãã•ã‚“é›†ã‚ã¦ã­ï¼ğŸŒ¸ã€`,
        `ã€ŒãŸã¬ãã•ã‚“ã®ãŠåº—ã§\nã„ã‚ã„ã‚è²·ãˆã‚‹ã‚ˆï¼ğŸªã€`,
        `ã€Œå·ã§ã•ã‹ãª\né‡£ã‚ŒãŸã‹ãªï¼ŸğŸŸã€`,
      ];
      const msg = messages[Math.floor(Math.random() * messages.length)];
      showMessage(msg);
    }
  }
}

// ========== UIæ›´æ–° ==========
function updateInventory() {
  document.getElementById('axe-count').textContent = inventory.wood;
  document.getElementById('fish-count').textContent = inventory.fish;
  document.getElementById('flower-count').textContent = inventory.flower;
  document.getElementById('mushroom-count').textContent = inventory.mushroom;
  document.getElementById('bell-count').textContent = bells.toLocaleString();
}

let msgTimeout;
function showMessage(text) {
  const el = document.getElementById('action-msg');
  el.textContent = '';
  el.style.display = 'block';
  el.style.animation = 'none';
  el.offsetHeight;
  el.style.animation = 'msgPop 0.3s ease-out';
  el.innerHTML = text.replace(/\n/g, '<br>');
  clearTimeout(msgTimeout);
  msgTimeout = setTimeout(() => {
    el.style.display = 'none';
  }, 2500);
}

function updateClock() {
  const now = new Date();
  const h = String(now.getHours()).padStart(2, '0');
  const m = String(now.getMinutes()).padStart(2, '0');
  document.getElementById('time-display').textContent = `${h}:${m}`;
}

function setTool(tool) {
  currentTool = tool;
  document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
  document.getElementById(`btn-${tool}`).classList.add('active');
  const toolNames = { walk: 'ğŸƒ æ­©ããƒ¢ãƒ¼ãƒ‰', axe: 'ğŸª“ ãŠã®ãƒ¢ãƒ¼ãƒ‰', fish: 'ğŸ£ ã¤ã‚Šãƒ¢ãƒ¼ãƒ‰', flower: 'ğŸŒ¸ èŠ±ã¤ã¿ãƒ¢ãƒ¼ãƒ‰', chat: 'ğŸ’¬ ã¯ãªã™ãƒ¢ãƒ¼ãƒ‰' };
  showMessage(toolNames[tool] + ' ã«åˆ‡ã‚Šæ›¿ãˆãŸï¼');
}

// ========== ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ— ==========
let time = 0;

function animate() {
  requestAnimationFrame(animate);
  const delta = clock.getDelta();
  time += delta;

  if (!gameStarted || !player) {
    renderer.render(scene, camera);
    return;
  }

  // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•
  const speed = 5.5;
  const forward = new THREE.Vector3(
    -Math.sin(cameraAngle), 0, -Math.cos(cameraAngle)
  );
  const right = new THREE.Vector3(
    Math.cos(cameraAngle), 0, -Math.sin(cameraAngle)
  );
  
  let moving = false;
  const moveVec = new THREE.Vector3();

  if (keys['w'] || keys['arrowup']) { moveVec.addScaledVector(forward, speed * delta); moving = true; }
  if (keys['s'] || keys['arrowdown']) { moveVec.addScaledVector(forward, -speed * delta); moving = true; }
  if (keys['a'] || keys['arrowleft']) { moveVec.addScaledVector(right, -speed * delta); moving = true; }
  if (keys['d'] || keys['arrowright']) { moveVec.addScaledVector(right, speed * delta); moving = true; }

  if (moving) {
    player.position.add(moveVec);
    // å³¶ã®å¤–ã«å‡ºãªã„ã‚ˆã†ã«åˆ¶é™
    const dist = Math.sqrt(player.position.x ** 2 + player.position.z ** 2);
    if (dist > 36) {
      player.position.multiplyScalar(36 / dist);
    }
    
    // ç§»å‹•æ–¹å‘ã‚’å‘ã
    if (moveVec.length() > 0) {
      const angle = Math.atan2(moveVec.x, moveVec.z);
      player.rotation.y = angle;
    }

    // æ­©ãã‚¢ãƒ‹ãƒ¡ï¼ˆä¸Šä¸‹æºã‚Œï¼‰
    player.position.y = Math.abs(Math.sin(time * 8)) * 0.06;
  } else {
    player.position.y = Math.abs(Math.sin(time * 2)) * 0.02;
  }

  // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒŸã‚­ã‚µãƒ¼æ›´æ–°
  if (mixer) mixer.update(delta);

  // NPCç§»å‹•ï¼ˆå·¡å›ï¼‰
  npcs.forEach(npc => {
    npc.userData.walkAngle += npc.userData.walkSpeed * delta;
    const tx = npc.userData.baseX + Math.cos(npc.userData.walkAngle) * npc.userData.walkRadius;
    const tz = npc.userData.baseZ + Math.sin(npc.userData.walkAngle) * npc.userData.walkRadius;
    npc.position.x += (tx - npc.position.x) * 0.05;
    npc.position.z += (tz - npc.position.z) * 0.05;
    npc.position.y = Math.abs(Math.sin(time * 4 + npc.userData.walkAngle)) * 0.04;
    
    const dx = tx - npc.position.x;
    const dz = tz - npc.position.z;
    if (Math.abs(dx) + Math.abs(dz) > 0.01) {
      npc.rotation.y = Math.atan2(dx, dz);
    }
  });

  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.userData.life -= delta * 1.5;
    p.position.add(p.userData.vel);
    p.userData.vel.y -= 0.004;
    p.material.opacity = p.userData.life;
    p.scale.setScalar(p.userData.life);
    if (p.userData.life <= 0) {
      scene.remove(p);
      particles.splice(i, 1);
    }
  }

  // èŠ±ãƒ»æœ¨ã®æºã‚Œ
  interactables.forEach(obj => {
    if (obj.userData.type === 'flower') {
      obj.rotation.z = Math.sin(time * 2 + obj.position.x) * 0.05;
    } else if (obj.userData.type === 'tree') {
      obj.children.forEach((c, j) => {
        if (j > 0) {
          c.rotation.z = Math.sin(time * 1.5 + obj.position.x + j) * 0.03;
        }
      });
    }
  });

  // æ°´é¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
  if (scene.userData.sea) {
    scene.userData.sea.position.y = -0.2 + Math.sin(time * 0.5) * 0.05;
    scene.userData.sea.material.opacity = 0.85 + Math.sin(time * 0.8) * 0.05;
  }

  updateCamera();
  renderer.render(scene, camera);
}
</script>
</body>
</html>
