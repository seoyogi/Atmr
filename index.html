<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ğŸŒ¿ ã‚ã¤ã¾ã‚Œï¼ã©ã†ã¶ã¤ã®æ£®</title>
<link href="https://fonts.googleapis.com/css2?family=Zen+Maru+Gothic:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --green: #3a7d44;
    --green-light: #a8d5a2;
    --green-pale: #d4f0d4;
    --sand: #f5e0a0;
    --sky: #87CEEB;
    --white-glass: rgba(255,255,255,0.90);
    --shadow: 0 4px 16px rgba(0,0,0,0.15);
  }

  * { margin:0; padding:0; box-sizing:border-box; }

  body {
    font-family: 'Zen Maru Gothic', sans-serif;
    background: var(--sky);
    overflow: hidden;
    width: 100vw; height: 100vh;
    user-select: none;
  }

  #renderCanvas {
    width: 100%; height: 100%;
    display: block;
    touch-action: none;
  }

  /* ========== ã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ ========== */
  #title-screen {
    position: fixed; inset: 0; z-index: 1000;
    background: linear-gradient(160deg, #7dd4f0 0%, #a8e6cf 55%, #5aad63 100%);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 0;
    transition: opacity 0.8s ease;
  }
  #title-screen.fade-out { opacity: 0; pointer-events: none; }

  .title-deco {
    font-size: clamp(40px, 8vw, 72px);
    letter-spacing: 4px;
    animation: floatDeco 3s ease-in-out infinite;
    margin-bottom: 8px;
  }
  @keyframes floatDeco {
    0%,100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }

  .title-main {
    font-size: clamp(26px, 5vw, 52px);
    font-weight: 900;
    color: #fff;
    text-shadow: 3px 3px 0 var(--green), -1px -1px 0 var(--green), 1px -1px 0 var(--green), -1px 1px 0 var(--green);
    letter-spacing: 3px;
    line-height: 1.25;
    text-align: center;
    margin-bottom: 6px;
  }

  .title-sub {
    font-size: clamp(12px, 2vw, 16px);
    color: rgba(255,255,255,0.9);
    font-weight: 700;
    letter-spacing: 2px;
    margin-bottom: 40px;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.25);
  }

  .start-btn {
    background: #fff;
    border: 4px solid var(--green);
    border-radius: 999px;
    padding: 14px 52px;
    font-size: 20px;
    font-weight: 900;
    color: var(--green);
    cursor: pointer;
    font-family: inherit;
    box-shadow: 0 6px 0 var(--green), var(--shadow);
    transition: all 0.15s;
    animation: btnBounce 1.8s ease-in-out infinite;
  }
  .start-btn:hover {
    transform: translateY(3px);
    box-shadow: 0 3px 0 var(--green), var(--shadow);
    animation: none;
    background: var(--green-pale);
  }
  .start-btn:active { transform: translateY(5px); box-shadow: 0 1px 0 var(--green); }
  @keyframes btnBounce {
    0%,100% { transform: translateY(0); }
    50% { transform: translateY(-7px); }
  }

  .title-grass {
    position: absolute; bottom: 0; left: 0; right: 0;
    height: 80px;
    background: linear-gradient(to top, #5aad63, transparent);
    display: flex; align-items: flex-end; justify-content: center;
    padding-bottom: 12px; gap: 6px; font-size: 28px;
  }

  /* ========== ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚° ========== */
  #loading {
    position: fixed; inset: 0; z-index: 999;
    background: var(--sky);
    display: none; flex-direction: column;
    align-items: center; justify-content: center;
    gap: 16px;
    font-size: 18px; font-weight: 700; color: var(--green);
  }
  .loader-ring {
    width: 56px; height: 56px;
    border: 5px solid var(--green-light);
    border-top-color: var(--green);
    border-radius: 50%;
    animation: spin 0.7s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }

  /* ========== HUD ========== */
  #hud { display: none; }

  /* ãƒˆãƒƒãƒ—ãƒãƒ¼ */
  #topbar {
    position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
    display: flex; align-items: center; gap: 16px;
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 999px;
    padding: 7px 22px;
    box-shadow: var(--shadow), inset 0 1px 0 rgba(255,255,255,0.8);
    z-index: 100;
    backdrop-filter: blur(8px);
  }
  #island-name { font-size: 17px; font-weight: 900; color: var(--green); }
  #bell-display {
    display: flex; align-items: center; gap: 5px;
    font-size: 15px; font-weight: 700; color: #c47f00;
  }

  /* æ™‚è¨ˆ */
  #clock {
    position: fixed; top: 12px; right: 16px;
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 14px; padding: 6px 14px;
    font-size: 14px; font-weight: 700; color: var(--green);
    box-shadow: var(--shadow); z-index: 100;
    backdrop-filter: blur(8px);
  }

  /* å¤©æ°— */
  #weather {
    position: fixed; top: 66px; left: 14px;
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 14px; padding: 9px 14px;
    font-size: 13px; font-weight: 700; color: var(--green);
    box-shadow: var(--shadow); z-index: 100;
    backdrop-filter: blur(8px); line-height: 1.7;
  }

  /* ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª */
  #inventory {
    position: fixed; top: 66px; right: 14px;
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 14px; padding: 12px 16px;
    z-index: 100; box-shadow: var(--shadow);
    backdrop-filter: blur(8px); min-width: 128px;
  }
  #inventory h3 {
    font-size: 12px; font-weight: 900; color: var(--green);
    text-align: center; border-bottom: 2px solid var(--green-light);
    padding-bottom: 6px; margin-bottom: 8px;
  }
  .inv-row {
    display: flex; align-items: center; gap: 6px;
    font-size: 12px; font-weight: 700; color: #444; padding: 2px 0;
  }

  /* ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ */
  #toolbar {
    position: fixed; bottom: 18px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 10px; z-index: 100;
  }
  .tbtn {
    width: 66px; height: 66px;
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 18px;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    cursor: pointer; gap: 3px;
    box-shadow: var(--shadow), 0 3px 0 #6bb56a;
    transition: all 0.14s;
    font-size: 27px;
    backdrop-filter: blur(8px);
  }
  .tbtn:hover { transform: translateY(-5px); box-shadow: 0 8px 20px rgba(0,0,0,0.2), 0 3px 0 #6bb56a; }
  .tbtn:active { transform: translateY(1px); box-shadow: 0 1px 6px rgba(0,0,0,0.15), 0 1px 0 #6bb56a; }
  .tbtn.active { background: var(--green-pale); border-color: var(--green); transform: translateY(-3px); }
  .tbtn-lbl { font-size: 9px; font-weight: 900; color: var(--green); line-height: 1; }

  /* æ“ä½œã‚¬ã‚¤ãƒ‰ */
  #guide {
    position: fixed; bottom: 100px; left: 14px;
    background: var(--white-glass);
    border: 2px solid var(--green-light);
    border-radius: 12px; padding: 10px 14px;
    font-size: 11px; color: var(--green); font-weight: 700;
    line-height: 1.9; z-index: 100; box-shadow: var(--shadow);
    backdrop-filter: blur(8px);
  }

  /* ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ */
  #msg {
    position: fixed; bottom: 110px; left: 50%; transform: translateX(-50%);
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 20px; padding: 14px 28px;
    font-size: 16px; font-weight: 700; color: var(--green);
    text-align: center; z-index: 200;
    box-shadow: 0 8px 24px rgba(0,0,0,0.18);
    backdrop-filter: blur(10px);
    display: none; white-space: pre-line;
    animation: msgPop 0.28s cubic-bezier(0.34,1.56,0.64,1);
    pointer-events: none;
  }
  @keyframes msgPop {
    from { transform: translateX(-50%) scale(0.75); opacity: 0; }
    to   { transform: translateX(-50%) scale(1);    opacity: 1; }
  }

  /* ãƒŸãƒ‹ãƒãƒƒãƒ— */
  #minimap {
    position: fixed; bottom: 100px; right: 14px;
    width: 88px; height: 88px;
    background: rgba(100,180,100,0.5);
    border: 3px solid var(--green-light);
    border-radius: 50%; z-index: 100;
    overflow: hidden;
    box-shadow: var(--shadow);
    backdrop-filter: blur(4px);
  }
  #minimap canvas { width: 100%; height: 100%; }

  /* ========== ä»®æƒ³ã‚¹ãƒ†ã‚£ãƒƒã‚¯ ========== */
  #joystick-container {
    position: fixed; bottom: 40px; left: 40px;
    width: 120px; height: 120px;
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.4);
    border-radius: 50%;
    z-index: 500;
    display: none;
    touch-action: none;
    backdrop-filter: blur(4px);
  }
  #joystick-knob {
    position: absolute; top: 50%; left: 50%;
    width: 50px; height: 50px;
    background: var(--white-glass);
    border: 3px solid var(--green-light);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    box-shadow: var(--shadow);
    pointer-events: none;
  }
</style>
</head>
<body>

<div id="title-screen">
  <div class="title-deco">ğŸŒ¸ğŸŒ³ğŸ¦‹ğŸŒ»ğŸ</div>
  <h1 class="title-main">ã‚ã¤ã¾ã‚Œï¼<br>ã©ã†ã¶ã¤ã®æ£®</h1>
  <p class="title-sub">ï½ ã¿ã‚“ãªã®ã—ã¾ã¸ ã‚ˆã†ã“ã ï½</p>
  <button class="start-btn" onclick="startGame()">ğŸ® ã¯ã˜ã‚ã‚‹ï¼</button>
  <div class="title-grass">ğŸŒ¿ğŸŒ±ğŸŒ¿ğŸŒ¾ğŸŒ¿ğŸŒ±ğŸŒ¿ğŸŒ¾ğŸŒ¿ğŸŒ±ğŸŒ¿</div>
</div>

<div id="loading">
  <div class="loader-ring"></div>
  <span>ã—ã¾ã‚’æº–å‚™ä¸­... ğŸŒ´</span>
</div>

<canvas id="renderCanvas"></canvas>

<div id="hud">
  <div id="topbar">
    <span id="island-name">ğŸŒ´ ãµã‚ãµã‚ã—ã¾</span>
    <div id="bell-display">ğŸ”” <span id="bells">12,500</span> ãƒ™ãƒ«</div>
  </div>
  <div id="clock">ğŸ• <span id="clock-val">--:--</span></div>
  <div id="weather">â˜€ï¸ ã¯ã‚Œ<br><span style="font-size:10px;color:#888;font-weight:500">æ°—æ¸© 22Â°C</span></div>
  <div id="inventory">
    <h3>ğŸ’ ã‚‚ã¡ã‚‚ã®</h3>
    <div class="inv-row">ğŸª“ <span id="i-wood">0</span> æœ¨æ</div>
    <div class="inv-row">ğŸŸ <span id="i-fish">0</span> ã•ã‹ãª</div>
    <div class="inv-row">ğŸŒ¸ <span id="i-flower">0</span> ã¯ãª</div>
    <div class="inv-row">ğŸ„ <span id="i-mush">0</span> ãã®ã“</div>
  </div>
  <div id="toolbar">
    <div class="tbtn active" id="tb-walk" onclick="setTool('walk')">ğŸƒ<span class="tbtn-lbl">æ­©ã</span></div>
    <div class="tbtn" id="tb-axe"  onclick="setTool('axe')">ğŸª“<span class="tbtn-lbl">ãŠã®</span></div>
    <div class="tbtn" id="tb-fish" onclick="setTool('fish')">ğŸ£<span class="tbtn-lbl">ã¤ã‚Š</span></div>
    <div class="tbtn" id="tb-flower" onclick="setTool('flower')">ğŸŒ¸<span class="tbtn-lbl">ã¯ãªã¤ã¿</span></div>
    <div class="tbtn" id="tb-chat" onclick="setTool('chat')">ğŸ’¬<span class="tbtn-lbl">ã¯ãªã™</span></div>
  </div>
  <div id="guide">
    <b>ğŸ® æ“ä½œ</b><br>
    ã‚¹ãƒ†ã‚£ãƒƒã‚¯ / WASD â†’ ç§»å‹•<br>
    ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚° â†’ è¦–ç‚¹<br>
    <b>E / ã‚¯ãƒªãƒƒã‚¯</b> â†’ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
  </div>
  <div id="minimap"><canvas id="mm-canvas" width="88" height="88"></canvas></div>
  <div id="msg"></div>

  <div id="joystick-container">
    <div id="joystick-knob"></div>
  </div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
// ============================================================
//  ã‚²ãƒ¼ãƒ çŠ¶æ…‹
// ============================================================
let engine, scene, camera, playerMesh, playerRoot;
let bellCount = 12500;
let inv = { wood:0, fish:0, flower:0, mushroom:0 };
let currentTool = 'walk';
let interactables = [];
let npcs = [];
let msgTimer = null;
let gameReady = false;

// ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯çŠ¶æ…‹
let joystickActive = false;
let joystickVector = { x: 0, y: 0 };

// ============================================================
//  ã‚¹ã‚¿ãƒ¼ãƒˆ
// ============================================================
function startGame() {
  document.getElementById('title-screen').classList.add('fade-out');
  document.getElementById('loading').style.display = 'flex';
  setTimeout(() => {
    initBabylon();
  }, 300);
}

// ============================================================
//  Babylon åˆæœŸåŒ–
// ============================================================
function initBabylon() {
  const canvas = document.getElementById('renderCanvas');
  engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
  scene  = new BABYLON.Scene(engine);

  scene.clearColor = new BABYLON.Color4(0.529, 0.808, 0.922, 1);
  scene.fogMode    = BABYLON.Scene.FOGMODE_EXP2;
  scene.fogDensity = 0.012;
  scene.fogColor   = new BABYLON.Color3(0.529, 0.808, 0.922);

  camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2, Math.PI/3.5, 14, BABYLON.Vector3.Zero(), scene);
  camera.lowerRadiusLimit = 4;
  camera.upperRadiusLimit = 28;
  camera.upperBetaLimit   = Math.PI / 2.1;
  camera.lowerBetaLimit   = 0.1;
  camera.attachControl(canvas, true);
  camera.panningSensibility = 0;

  const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -2, -1), scene);
  sun.intensity = 1.1;
  sun.diffuse   = new BABYLON.Color3(1, 0.97, 0.85);

  const ambient = new BABYLON.HemisphericLight("amb", new BABYLON.Vector3(0,1,0), scene);
  ambient.intensity   = 0.55;
  ambient.groundColor = new BABYLON.Color3(0.4, 0.7, 0.35);

  const shadowGen = new BABYLON.ShadowGenerator(1024, sun);
  shadowGen.useBlurExponentialShadowMap = true;

  buildIsland(scene, shadowGen);
  loadPlayer(scene, shadowGen);
  setupInput(scene, canvas);
  setupJoystick();

  let t = 0;
  engine.runRenderLoop(() => {
    const dt = engine.getDeltaTime() / 1000;
    t += dt;
    updatePlayer(dt);
    updateNPCs(dt, t);
    updateParticles(dt);
    wigglePlants(t);
    updateMinimap();
    scene.render();
  });

  window.addEventListener('resize', () => engine.resize());
  updateClock();
  setInterval(updateClock, 30000);
}

// ============================================================
//  å³¶ã‚’æ§‹ç¯‰
// ============================================================
function buildIsland(scene, sg) {
  const mat = (color) => {
    const m = new BABYLON.StandardMaterial("m_"+Math.random(), scene);
    m.diffuseColor = BABYLON.Color3.FromHexString(color);
    return m;
  };

  const sea = BABYLON.MeshBuilder.CreateDisc("sea", { radius: 65, tessellation: 48 }, scene);
  sea.rotation.x = Math.PI / 2;
  sea.position.y = -0.18;
  sea.material   = mat("#3cb5cc");
  sea.material.alpha = 0.92;

  const beach = BABYLON.MeshBuilder.CreateTorus("beach", { diameter: 78, thickness: 8, tessellation: 48 }, scene);
  beach.scaling.y = 0.04;
  beach.position.y = 0.005;
  beach.material   = mat("#f5e0a0");

  const ground = BABYLON.MeshBuilder.CreateDisc("ground", { radius: 40, tessellation: 48 }, scene);
  ground.rotation.x = Math.PI / 2;
  ground.receiveShadows = true;
  ground.material       = mat("#5aad63");

  for (let i = 0; i < 10; i++) {
    const p = BABYLON.MeshBuilder.CreateBox("path"+i, { width:1.6, height:0.04, depth:2.6 }, scene);
    const a = (i / 10) * Math.PI * 2;
    p.position.set(Math.sin(a)*6, 0.02, Math.cos(a)*6);
    p.rotation.y = a;
    p.material   = mat("#e8d5a0");
  }

  const treePos = [
    [-8,-8],[8,-10],[-12,3],[12,5],[-6,12],[7,13],
    [-14,-2],[14,-3],[-3,-15],[4,-16],[0,-12],
    [-10,10],[10,-8],[-5,18],[5,19],[-18,6],[18,2]
  ];
  treePos.forEach((p,i) => buildTree(p[0],p[1],i,scene,sg));

  const flowerPos = [[-4,-4],[4,-5],[-6,6],[6,8],[2,10],[-3,7],[0,-8],[-8,-1],[8,1],[3,-12],[-2,-10]];
  const flowerColors = ["#ff69b4","#ff4444","#ffcc00","#ff88cc","#cc44ff","#ffffff"];
  flowerPos.forEach((p,i) => buildFlower(p[0],p[1],flowerColors[i%flowerColors.length],i,scene,sg));

  buildRiver(scene);

  [[3,2],[-5,4],[7,-3],[-2,9]].forEach((p,i) => buildMushroom(p[0],p[1],i,scene,sg));

  buildHouse(0,-20, "#ffdab9", scene, sg);
  buildHouse(-9,-22,"#ffc0cb", scene, sg);
  buildHouse(9,-22, "#c0e8ff", scene, sg);

  buildNPC(-6, 2,"#ffaa88","ãŸã¬ã", scene, sg);
  buildNPC(5, -5,"#88aaff","ã‚Šã™ã®ã“",scene,sg);
  buildNPC(-3, 8,"#ff88aa","ã†ã—ã“",  scene,sg);
}

function buildTree(x, z, seed, scene, sg) {
  const root = new BABYLON.TransformNode("tree_"+seed, scene);
  root.position.set(x, 0, z);
  const trunkMat = new BABYLON.StandardMaterial("tm"+seed, scene);
  trunkMat.diffuseColor = BABYLON.Color3.FromHexString("#8B5A2B");
  const trunk = BABYLON.MeshBuilder.CreateCylinder("tr"+seed, { diameterTop:0.36, diameterBottom:0.5, height:2.6, tessellation:8 }, scene);
  trunk.position.set(x, 1.3, z);
  trunk.material = trunkMat;
  trunk.receiveShadows = true;
  sg.addShadowCaster(trunk);
  const leafColors = ["#2d8a2d","#3aa33a","#4ab54a"];
  [3.6,2.9,2.3].forEach((h,j) => {
    const lm = new BABYLON.StandardMaterial("lm"+seed+j, scene);
    lm.diffuseColor = BABYLON.Color3.FromHexString(leafColors[j]);
    const leaf = BABYLON.MeshBuilder.CreateSphere("lf"+seed+j, { diameter:(5-j)/2, segments:6 }, scene);
    leaf.scaling.y = 0.7;
    leaf.position.set(x, h, z);
    leaf.material  = lm;
    sg.addShadowCaster(leaf);
    leaf.receiveShadows = true;
  });
  if (seed % 3 === 1) {
    const fc = ["#ff4444","#ff8800","#ffcc00"][seed % 3];
    const fm = new BABYLON.StandardMaterial("fm"+seed, scene);
    fm.diffuseColor = BABYLON.Color3.FromHexString(fc);
    for (let i = 0; i < 4; i++) {
      const f = BABYLON.MeshBuilder.CreateSphere("fr"+seed+i, { diameter:0.4, segments:4 }, scene);
      f.position.set(x + Math.cos(i*Math.PI/2)*1.5, 2.6, z + Math.sin(i*Math.PI/2)*1.5);
      f.material = fm;
    }
  }
  root.userData = { type:'tree', hasWood:true, trunk, x, z };
  interactables.push(root);
  return root;
}

function buildFlower(x, z, color, idx, scene, sg) {
  const root = new BABYLON.TransformNode("flower_"+idx, scene);
  root.position.set(x, 0, z);
  const stemM = new BABYLON.StandardMaterial("sm"+idx, scene);
  stemM.diffuseColor = BABYLON.Color3.FromHexString("#4a9e4a");
  const stem = BABYLON.MeshBuilder.CreateCylinder("st"+idx, { diameter:0.08, height:0.5 }, scene);
  stem.position.set(x, 0.25, z);
  stem.material = stemM;
  const petalM = new BABYLON.StandardMaterial("pm"+idx, scene);
  petalM.diffuseColor = BABYLON.Color3.FromHexString(color);
  for (let i = 0; i < 5; i++) {
    const p = BABYLON.MeshBuilder.CreateSphere("pt"+idx+i, { diameter:0.3, segments:4 }, scene);
    p.scaling.y = 0.5;
    p.position.set(x+Math.cos(i*Math.PI*2/5)*0.2, 0.52, z+Math.sin(i*Math.PI*2/5)*0.2);
    p.material = petalM;
    sg.addShadowCaster(p);
  }
  const coreM = new BABYLON.StandardMaterial("cm"+idx, scene);
  coreM.diffuseColor = BABYLON.Color3.FromHexString("#ffdd00");
  const core = BABYLON.MeshBuilder.CreateSphere("co"+idx, { diameter:0.24, segments:4 }, scene);
  core.position.set(x, 0.54, z);
  core.material = coreM;
  root.userData = { type:'flower', hasFlower:true, x, z };
  root.metadata  = { visible: true };
  interactables.push(root);
  return root;
}

function buildRiver(scene) {
  const riverM = new BABYLON.StandardMaterial("riverM", scene);
  riverM.diffuseColor = BABYLON.Color3.FromHexString("#4ab5cc");
  riverM.alpha = 0.85;
  for (let i = 0; i < 18; i++) {
    const t = i / 18;
    const seg = BABYLON.MeshBuilder.CreateCylinder("rs"+i, { diameter:1.8, height:0.15, tessellation:12 }, scene);
    seg.position.set(Math.sin(t * Math.PI * 2.5) * 3 - 6, 0.06, t * 32 - 18);
    seg.material = riverM;
  }
  const fishPt = new BABYLON.TransformNode("fishpt", scene);
  fishPt.position.set(-6, 0, 0);
  fishPt.userData = { type:'river', hasFish:true };
  interactables.push(fishPt);
  const bobM = new BABYLON.StandardMaterial("bobM", scene);
  bobM.diffuseColor = BABYLON.Color3.FromHexString("#4ab5cc");
  bobM.alpha = 0.7;
  const bob = BABYLON.MeshBuilder.CreateSphere("bob", { diameter:0.6 }, scene);
  bob.position.set(-6, 0.3, 0);
  bob.material = bobM;
}

function buildMushroom(x, z, idx, scene, sg) {
  const root = new BABYLON.TransformNode("mush_"+idx, scene);
  root.position.set(x, 0, z);
  const stemM = new BABYLON.StandardMaterial("mustem"+idx, scene);
  stemM.diffuseColor = BABYLON.Color3.FromHexString("#fffacd");
  const stem = BABYLON.MeshBuilder.CreateCylinder("mst"+idx, { diameterTop:0.24, diameterBottom:0.32, height:0.5 }, scene);
  stem.position.set(x, 0.25, z);
  stem.material = stemM;
  const capColors = ["#ff4444","#ff8800","#ffcc00","#aa44ff"];
  const capM = new BABYLON.StandardMaterial("mcap"+idx, scene);
  capM.diffuseColor = BABYLON.Color3.FromHexString(capColors[idx % 4]);
  const cap = BABYLON.MeshBuilder.CreateSphere("mcp"+idx, { diameter:0.7, segments:6 }, scene);
  cap.scaling.y = 0.65;
  cap.position.set(x, 0.68, z);
  cap.material = capM;
  sg.addShadowCaster(cap);
  const dotM = new BABYLON.StandardMaterial("mdot"+idx, scene);
  dotM.diffuseColor = BABYLON.Color3.White();
  for (let i = 0; i < 4; i++) {
    const d = BABYLON.MeshBuilder.CreateSphere("md"+idx+i, { diameter:0.1, segments:3 }, scene);
    d.position.set(x+Math.cos(i*Math.PI/2)*0.22, 0.76, z+Math.sin(i*Math.PI/2)*0.22);
    d.material = dotM;
  }
  root.userData = { type:'mushroom', hasMushroom:true, x, z };
  interactables.push(root);
  return root;
}

function buildHouse(x, z, wallColor, scene, sg) {
  const wm = new BABYLON.StandardMaterial("wm"+x, scene);
  wm.diffuseColor = BABYLON.Color3.FromHexString(wallColor);
  const wall = BABYLON.MeshBuilder.CreateBox("wall"+x, { width:4.2, height:3.2, depth:4.2 }, scene);
  wall.position.set(x, 1.6, z);
  wall.material = wm;
  sg.addShadowCaster(wall);
  wall.receiveShadows = true;
  const rm = new BABYLON.StandardMaterial("rm"+x, scene);
  rm.diffuseColor = BABYLON.Color3.FromHexString("#8B4513");
  const roof = BABYLON.MeshBuilder.CreateCylinder("roof"+x, { diameterTop:0, diameterBottom:6.4, height:2.2, tessellation:4 }, scene);
  roof.position.set(x, 4.3, z);
  roof.rotation.y = Math.PI / 4;
  roof.material   = rm;
  sg.addShadowCaster(roof);
  const dm = new BABYLON.StandardMaterial("dm"+x, scene);
  dm.diffuseColor = BABYLON.Color3.FromHexString("#8B5A2B");
  const door = BABYLON.MeshBuilder.CreateBox("door"+x, { width:0.9, height:1.6, depth:0.12 }, scene);
  door.position.set(x, 0.8, z+2.16);
  door.material = dm;
  const wndm = new BABYLON.StandardMaterial("wndm"+x, scene);
  wndm.diffuseColor = BABYLON.Color3.FromHexString("#87ceeb");
  [-1.3,1.3].forEach(wx => {
    const wnd = BABYLON.MeshBuilder.CreateBox("wnd"+x+wx, { width:0.75, height:0.75, depth:0.1 }, scene);
    wnd.position.set(x+wx, 1.9, z+2.16);
    wnd.material = wndm;
  });
}

function buildNPC(x, z, color, name, scene, sg) {
  const root = new BABYLON.TransformNode("npc_"+name, scene);
  root.position.set(x, 0, z);
  const bm = new BABYLON.StandardMaterial("nm_b"+name, scene);
  bm.diffuseColor = BABYLON.Color3.FromHexString(color);
  const body = BABYLON.MeshBuilder.CreateCapsule("nb_"+name, { radius:0.35, height:1.4, tessellation:8 }, scene);
  body.position.set(x, 0.85, z);
  body.material = bm;
  sg.addShadowCaster(body);
  const head = BABYLON.MeshBuilder.CreateSphere("nh_"+name, { diameter:0.76, segments:8 }, scene);
  head.position.set(x, 1.75, z);
  head.material = bm;
  sg.addShadowCaster(head);
  const em = new BABYLON.StandardMaterial("em_"+name, scene);
  em.diffuseColor = BABYLON.Color3.FromHexString("#222222");
  [-0.13,0.13].forEach(ex => {
    const eye = BABYLON.MeshBuilder.CreateSphere("eye"+name+ex, { diameter:0.12, segments:5 }, scene);
    eye.position.set(x+ex, 1.8, z+0.32);
    eye.material = em;
  });
  const earm = new BABYLON.StandardMaterial("earm_"+name, scene);
  earm.diffuseColor = BABYLON.Color3.FromHexString(color);
  [-0.26,0.26].forEach(ex => {
    const ear = BABYLON.MeshBuilder.CreateSphere("ear"+name+ex, { diameter:0.24, segments:5 }, scene);
    ear.scaling.y = 1.5;
    ear.position.set(x+ex, 2.08, z);
    ear.material = earm;
  });
  root.userData = {
    type:'npc', name,
    walkAngle: Math.random()*Math.PI*2,
    walkR: 2+Math.random()*1.5,
    walkSpeed: 0.3+Math.random()*0.3,
    baseX: x, baseZ: z,
    bodyMesh: body, headMesh: head
  };
  npcs.push(root);
  interactables.push(root);
  return root;
}

function loadPlayer(scene, sg) {
  playerRoot = new BABYLON.TransformNode("playerRoot", scene);
  playerRoot.position.set(0, 0, 0);
  BABYLON.SceneLoader.ImportMesh(
    "", "./", "girl%20character%203d%20model.glb", scene,
    (meshes, ps, skeletons, animGroups) => {
      playerMesh = meshes[0];
      playerMesh.parent = playerRoot;
      const bbox = playerMesh.getHierarchyBoundingVectors();
      const size = bbox.max.subtract(bbox.min);
      const maxDim = Math.max(size.x, size.y, size.z);
      if (maxDim > 0) {
        const s = 1.8 / maxDim;
        playerMesh.scaling.set(s, s, s);
      }
      const bbox2 = playerMesh.getHierarchyBoundingVectors();
      playerMesh.position.y = -bbox2.min.y;
      meshes.forEach(m => {
        m.receiveShadows = true;
        sg.addShadowCaster(m, true);
      });
      if (animGroups && animGroups.length > 0) {
        animGroups[0].start(true);
      }
      finishLoading();
    },
    null,
    (s, msg) => {
      console.warn("GLB load failed:", msg);
      buildFallbackPlayer(scene, sg);
      finishLoading();
    }
  );
}

function buildFallbackPlayer(scene, sg) {
  playerRoot = new BABYLON.TransformNode("playerRoot", scene);
  playerRoot.position.set(0, 0, 0);
  const bm = new BABYLON.StandardMaterial("pb", scene);
  bm.diffuseColor = BABYLON.Color3.FromHexString("#ff8fa0");
  const body = BABYLON.MeshBuilder.CreateCapsule("pbody", { radius:0.3, height:1.3, tessellation:8 }, scene);
  body.position.set(0, 0.9, 0);
  body.material = bm;
  body.parent   = playerRoot;
  sg.addShadowCaster(body);
  const hm = new BABYLON.StandardMaterial("ph", scene);
  hm.diffuseColor = BABYLON.Color3.FromHexString("#ffcdb4");
  const head = BABYLON.MeshBuilder.CreateSphere("phead", { diameter:0.72, segments:8 }, scene);
  head.position.set(0, 1.72, 0);
  head.material = hm;
  head.parent   = playerRoot;
  sg.addShadowCaster(head);
  const hairM = new BABYLON.StandardMaterial("phr", scene);
  hairM.diffuseColor = BABYLON.Color3.FromHexString("#3a2010");
  const hair = BABYLON.MeshBuilder.CreateSphere("phair", { diameter:0.8, segments:8 }, scene);
  hair.scaling.set(1, 0.62, 1);
  hair.position.set(0, 1.96, 0);
  hair.material = hairM;
  hair.parent   = playerRoot;
  const em = new BABYLON.StandardMaterial("pem", scene);
  em.diffuseColor = BABYLON.Color3.FromHexString("#3a2020");
  [-0.14,0.14].forEach(ex => {
    const eye = BABYLON.MeshBuilder.CreateSphere("peye"+ex, { diameter:0.13, segments:5 }, scene);
    eye.position.set(ex, 1.78, 0.31);
    eye.material = em;
    eye.parent   = playerRoot;
    const hlM = new BABYLON.StandardMaterial("phl"+ex, scene);
    hlM.diffuseColor = BABYLON.Color3.White();
    const hl = BABYLON.MeshBuilder.CreateSphere("phl"+ex, { diameter:0.04, segments:3 }, scene);
    hl.position.set(ex+0.02, 1.8, 0.36);
    hl.material = hlM;
    hl.parent   = playerRoot;
  });
  const cheekM = new BABYLON.StandardMaterial("pchm", scene);
  cheekM.diffuseColor = BABYLON.Color3.FromHexString("#ffaaaa");
  cheekM.alpha = 0.7;
  [-0.26,0.26].forEach(cx => {
    const ch = BABYLON.MeshBuilder.CreateSphere("pch"+cx, { diameter:0.2, segments:5 }, scene);
    ch.scaling.z = 0.3;
    ch.position.set(cx, 1.68, 0.29);
    ch.material = cheekM;
    ch.parent   = playerRoot;
  });
  playerMesh = body;
}

function finishLoading() {
  document.getElementById('loading').style.display = 'none';
  document.getElementById('hud').style.display = 'block';
  document.getElementById('joystick-container').style.display = 'block';
  gameReady = true;
  showMsg("ğŸŒ´ ãµã‚ãµã‚ã—ã¾ã¸ã‚ˆã†ã“ãï¼\nå¥½ããªã“ã¨ã‚’ã—ã¦éã”ãã†â™ª");
}

// ============================================================
//  å…¥åŠ›è¨­å®š (ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ & ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯)
// ============================================================
const keys = {};
function setupInput(scene, canvas) {
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'e') tryInteract();
  });
  window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

  let mdown = {x:0,y:0};
  canvas.addEventListener('pointerdown', e => { mdown={x:e.clientX,y:e.clientY}; });
  canvas.addEventListener('pointerup',   e => {
    const dx = Math.abs(e.clientX-mdown.x), dy=Math.abs(e.clientY-mdown.y);
    if (dx+dy < 8) tryInteract();
  });
}

function setupJoystick() {
  const container = document.getElementById('joystick-container');
  const knob = document.getElementById('joystick-knob');
  const rect = container.getBoundingClientRect();
  const centerX = rect.width / 2;
  const centerY = rect.height / 2;
  const maxRadius = rect.width / 2;

  const handleMove = (e) => {
    if (!joystickActive) return;
    const touch = e.touches ? e.touches[0] : e;
    let dx = touch.clientX - (container.offsetLeft + centerX);
    let dy = touch.clientY - (container.offsetTop + centerY);
    
    const dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > maxRadius) {
      dx *= maxRadius / dist;
      dy *= maxRadius / dist;
    }
    
    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
    joystickVector = { x: dx / maxRadius, y: dy / maxRadius };
  };

  const handleEnd = () => {
    joystickActive = false;
    knob.style.transform = `translate(-50%, -50%)`;
    joystickVector = { x: 0, y: 0 };
  };

  container.addEventListener('pointerdown', (e) => {
    joystickActive = true;
    handleMove(e);
  });
  window.addEventListener('pointermove', handleMove);
  window.addEventListener('pointerup', handleEnd);
}

// ============================================================
//  ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ›´æ–°
// ============================================================
let walkTime = 0;
function updatePlayer(dt) {
  if (!gameReady || !playerRoot) return;

  const speed  = 5.5;
  const camY   = camera.alpha;
  const forward = new BABYLON.Vector3(-Math.sin(camY), 0, -Math.cos(camY));
  const right   = new BABYLON.Vector3( Math.cos(camY), 0, -Math.sin(camY));

  let move = BABYLON.Vector3.Zero();
  let moving = false;

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›
  if (keys['w']||keys['arrowup'])    { move.addInPlace(forward); moving=true; }
  if (keys['s']||keys['arrowdown'])  { move.addInPlace(forward.scale(-1)); moving=true; }
  if (keys['a']||keys['arrowleft'])  { move.addInPlace(right.scale(-1)); moving=true; }
  if (keys['d']||keys['arrowright']) { move.addInPlace(right); moving=true; }

  // ã‚¸ãƒ§ã‚¤ã‚¹ãƒ†ã‚£ãƒƒã‚¯å…¥åŠ›
  if (joystickActive && (Math.abs(joystickVector.x) > 0.1 || Math.abs(joystickVector.y) > 0.1)) {
    const joyMove = forward.scale(-joystickVector.y).add(right.scale(joystickVector.x));
    move.addInPlace(joyMove);
    moving = true;
  }

  if (moving && move.length() > 0) {
    move.normalize().scaleInPlace(speed * dt);
    playerRoot.position.addInPlace(move);
    const dist = Math.sqrt(playerRoot.position.x**2 + playerRoot.position.z**2);
    if (dist > 37) {
      playerRoot.position.x *= 37/dist;
      playerRoot.position.z *= 37/dist;
    }
    playerRoot.rotation.y = Math.atan2(move.x, move.z);
    walkTime += dt;
    playerRoot.position.y = Math.abs(Math.sin(walkTime * 8)) * 0.06;
  } else {
    walkTime += dt;
    playerRoot.position.y = Math.abs(Math.sin(walkTime * 1.5)) * 0.02;
  }
  camera.target = playerRoot.position.clone().add(new BABYLON.Vector3(0,1,0));
}

function updateNPCs(dt, t) {
  npcs.forEach(npc => {
    const ud = npc.userData;
    ud.walkAngle += ud.walkSpeed * dt;
    const tx = ud.baseX + Math.cos(ud.walkAngle) * ud.walkR;
    const tz = ud.baseZ + Math.sin(ud.walkAngle) * ud.walkR;
    npc.position.x += (tx - npc.position.x) * 0.05;
    npc.position.z += (tz - npc.position.z) * 0.05;
    npc.position.y  = Math.abs(Math.sin(t*3.5+ud.walkAngle)) * 0.04;
    const dx = tx - npc.position.x, dz = tz - npc.position.z;
    if (Math.abs(dx)+Math.abs(dz) > 0.01) {
      npc.rotation.y = Math.atan2(dx, dz);
    }
    if (ud.bodyMesh) {
      ud.bodyMesh.position.set(npc.position.x, npc.position.y+0.85, npc.position.z);
      ud.headMesh.position.set(npc.position.x, npc.position.y+1.75, npc.position.z);
    }
  });
}

function wigglePlants(t) {
  interactables.forEach(obj => {
    if (obj.userData && obj.userData.type === 'flower' && obj.metadata?.visible) {
      obj.rotation.z = Math.sin(t * 2 + obj.position.x) * 0.06;
    }
  });
}

let particles = [];
function spawnParticles(x, y, z, hexColor) {
  const m = new BABYLON.StandardMaterial("pm"+Date.now(), scene);
  m.diffuseColor = BABYLON.Color3.FromHexString(hexColor);
  m.emissiveColor = BABYLON.Color3.FromHexString(hexColor);
  for (let i = 0; i < 10; i++) {
    const p = BABYLON.MeshBuilder.CreateSphere("par"+Date.now()+i, { diameter:0.12, segments:3 }, scene);
    p.material = m;
    p.position.set(x, y, z);
    p.metadata = {
      vel: new BABYLON.Vector3((Math.random()-.5)*.4, .15+Math.random()*.2, (Math.random()-.5)*.4),
      life: 1.0
    };
    particles.push(p);
  }
}

function updateParticles(dt) {
  for (let i = particles.length-1; i >= 0; i--) {
    const p = particles[i];
    if (!p.metadata) continue;
    p.metadata.life -= dt * 1.8;
    p.position.addInPlace(p.metadata.vel);
    p.metadata.vel.y -= 0.006;
    p.scaling.setAll(Math.max(0, p.metadata.life));
    if (p.metadata.life <= 0) {
      p.dispose();
      particles.splice(i, 1);
    }
  }
}

function tryInteract() {
  if (!gameReady || !playerRoot) return;
  let nearest = null, nearDist = 3.8;
  interactables.forEach(obj => {
    const ox = obj.position?.x ?? obj.userData?.x ?? 0;
    const oz = obj.position?.z ?? obj.userData?.z ?? 0;
    const d  = Math.sqrt((playerRoot.position.x-ox)**2 + (playerRoot.position.z-oz)**2);
    if (d < nearDist) { nearest=obj; nearDist=d; }
  });
  if (!nearest) { showMsg("è¿‘ãã«ä½•ã‚‚ãªã„ã‚ˆã€œ\næ­©ã„ã¦æ¢ã—ã¦ã¿ã‚ˆã†ï¼ğŸŒ¿"); return; }
  const ud = nearest.userData;
  if (!ud) return;
  if (ud.type === 'tree' && ud.hasWood) {
    if (currentTool === 'axe') {
      inv.wood++; bellCount += 150; ud.hasWood = false;
      spawnParticles(nearest.position.x, 2, nearest.position.z, "#c8a060");
      updateUI(); showMsg("ğŸª“ æœ¨æã‚’ã‚²ãƒƒãƒˆï¼\n+150ãƒ™ãƒ« ğŸ’°");
    } else showMsg("ğŸª“ ãŠã®ã‚’é¸ã‚“ã§ã‹ã‚‰\næœ¨ã‚’åˆ‡ã‚ã†ï¼");
  } else if (ud.type === 'river' && ud.hasFish) {
    if (currentTool === 'fish') {
      inv.fish++; bellCount += 300;
      spawnParticles(nearest.position.x, 0.5, nearest.position.z, "#4ab5cc");
      updateUI(); showMsg("ğŸŸ ã•ã‹ãªã‚’é‡£ã£ãŸï¼\n+300ãƒ™ãƒ« ğŸ’°");
    } else showMsg("ğŸ£ ã¤ã‚Šã–ãŠã‚’é¸ã‚“ã§ã‹ã‚‰\nå·ã§é‡£ã‚Šã‚’ã—ã‚ˆã†ï¼");
  } else if (ud.type === 'flower' && ud.hasFlower) {
    inv.flower++; bellCount += 80; ud.hasFlower = false;
    nearest.metadata = { visible: false };
    scene.meshes.filter(m => m.name.startsWith("pt"+interactables.indexOf(nearest)) ||
      m.name.startsWith("co"+interactables.indexOf(nearest)) ||
      m.name.startsWith("st"+interactables.indexOf(nearest))
    ).forEach(m => m.isVisible = false);
    spawnParticles(nearest.position.x, 0.5, nearest.position.z, "#ff69b4");
    updateUI(); showMsg("ğŸŒ¸ ã¯ãªã‚’æ‘˜ã‚“ã ï¼\n+80ãƒ™ãƒ« ğŸ’°");
  } else if (ud.type === 'mushroom' && ud.hasMushroom) {
    inv.mushroom++; bellCount += 200; ud.hasMushroom = false;
    spawnParticles(nearest.position.x, 0.5, nearest.position.z, "#ff4444");
    updateUI(); showMsg("ğŸ„ ãã®ã“ã‚’ã¨ã£ãŸï¼\n+200ãƒ™ãƒ« ğŸ’°");
  } else if (ud.type === 'npc') {
    const msgs = [
      `ã€Œã“ã‚“ã«ã¡ã¯ï¼\n${ud.name}ã ã‚ˆï¼âœ¨ã€`,
      `ã€Œä»Šæ—¥ã‚‚ã„ã„å¤©æ°—ã ã­ï¼\nã„ã£ã—ã‚‡ã«ã‚ãã¼ã†â™ªã€`,
      `ã€ŒãŸãã•ã‚“é›†ã‚ã¦ã­ï¼\nãƒ™ãƒ«ã‚‚ã‚²ãƒƒãƒˆã—ã‚ˆã†ğŸ””ã€`,
      `ã€Œå·ã§ã•ã‹ãª\né‡£ã‚ŒãŸã‹ãªï¼ŸğŸŸã€`,
      `ã€Œã¯ãªã‚‚å’²ã„ã¦ã‚‹ã‚ˆã€œ\næ‘˜ã‚“ã§ã¿ã¦ï¼ğŸŒ¸ã€`,
    ];
    showMsg(msgs[Math.floor(Math.random()*msgs.length)]);
  } else {
    showMsg("è¿‘ãã«ä½•ã‚‚ãªã„ã‚ˆã€œ\næ­©ã„ã¦æ¢ã—ã¦ã¿ã‚ˆã†ï¼ğŸŒ¿");
  }
}

function updateMinimap() {
  if (!playerRoot) return;
  const canvas = document.getElementById('mm-canvas');
  const ctx    = canvas.getContext('2d');
  const W=88, H=88, cx=44, cy=44, scale=1.8;
  ctx.clearRect(0,0,W,H);
  ctx.fillStyle='rgba(80,160,80,0.5)'; ctx.beginPath(); ctx.arc(cx,cy,42,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#2d6a2d';
  interactables.filter(o=>o.userData?.type==='tree').forEach(o=>{
    ctx.beginPath(); ctx.arc(cx+o.position.x/scale, cy+o.position.z/scale, 3, 0, Math.PI*2); ctx.fill();
  });
  ctx.fillStyle='#ff8800';
  npcs.forEach(n=>{
    ctx.beginPath(); ctx.arc(cx+n.position.x/scale, cy+n.position.z/scale, 3, 0, Math.PI*2); ctx.fill();
  });
  ctx.fillStyle='#fff';
  ctx.beginPath(); ctx.arc(cx+playerRoot.position.x/scale, cy+playerRoot.position.z/scale, 4, 0, Math.PI*2); ctx.fill();
  ctx.strokeStyle='#3a7d44'; ctx.lineWidth=1.5; ctx.stroke();
}

function setTool(t) {
  currentTool = t;
  document.querySelectorAll('.tbtn').forEach(b=>b.classList.remove('active'));
  document.getElementById('tb-'+t).classList.add('active');
  const n={walk:'ğŸƒæ­©ããƒ¢ãƒ¼ãƒ‰',axe:'ğŸª“ãŠã®ãƒ¢ãƒ¼ãƒ‰',fish:'ğŸ£ã¤ã‚Šãƒ¢ãƒ¼ãƒ‰',flower:'ğŸŒ¸ã¯ãªã¤ã¿ãƒ¢ãƒ¼ãƒ‰',chat:'ğŸ’¬ã¯ãªã™ãƒ¢ãƒ¼ãƒ‰'};
  showMsg(n[t]+" ã«åˆ‡ã‚Šæ›¿ãˆãŸï¼");
}

function updateUI() {
  document.getElementById('bells').textContent   = bellCount.toLocaleString();
  document.getElementById('i-wood').textContent  = inv.wood;
  document.getElementById('i-fish').textContent  = inv.fish;
  document.getElementById('i-flower').textContent= inv.flower;
  document.getElementById('i-mush').textContent  = inv.mushroom;
}

function showMsg(text) {
  const el = document.getElementById('msg');
  el.style.display = 'none';
  void el.offsetWidth;
  el.innerHTML = text.replace(/\n/g,'<br>');
  el.style.display = 'block';
  clearTimeout(msgTimer);
  msgTimer = setTimeout(()=>{ el.style.display='none'; }, 2800);
}

function updateClock() {
  const n=new Date(), h=String(n.getHours()).padStart(2,'0'), m=String(n.getMinutes()).padStart(2,'0');
  document.getElementById('clock-val').textContent = h+':'+m;
}
</script>
</body>
</html>
